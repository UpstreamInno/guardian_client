{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { EventEmitter, UnavailabilityError } from '@unimodules/core';\nimport ExpoTaskManager from \"./ExpoTaskManager\";\nvar tasks = new Map();\n\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new TypeError('`taskName` must be a non-empty string.');\n  }\n}\n\nexport function defineTask(taskName, taskExecutor) {\n  if (!taskName || typeof taskName !== 'string') {\n    console.warn(\"TaskManager.defineTask: 'taskName' argument must be a non-empty string.\");\n    return;\n  }\n\n  if (!taskExecutor || typeof taskExecutor !== 'function') {\n    console.warn(\"TaskManager.defineTask: 'task' argument must be a function.\");\n    return;\n  }\n\n  tasks.set(taskName, taskExecutor);\n}\nexport function isTaskDefined(taskName) {\n  return tasks.has(taskName);\n}\nexport function isTaskRegisteredAsync(taskName) {\n  return _regeneratorRuntime.async(function isTaskRegisteredAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (ExpoTaskManager.isTaskRegisteredAsync) {\n            _context.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('TaskManager', 'isTaskRegisteredAsync');\n\n        case 2:\n          _validateTaskName(taskName);\n\n          return _context.abrupt(\"return\", ExpoTaskManager.isTaskRegisteredAsync(taskName));\n\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getTaskOptionsAsync(taskName) {\n  return _regeneratorRuntime.async(function getTaskOptionsAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (ExpoTaskManager.getTaskOptionsAsync) {\n            _context2.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('TaskManager', 'getTaskOptionsAsync');\n\n        case 2:\n          _validateTaskName(taskName);\n\n          return _context2.abrupt(\"return\", ExpoTaskManager.getTaskOptionsAsync(taskName));\n\n        case 4:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getRegisteredTasksAsync() {\n  return _regeneratorRuntime.async(function getRegisteredTasksAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          if (ExpoTaskManager.getRegisteredTasksAsync) {\n            _context3.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('TaskManager', 'getRegisteredTasksAsync');\n\n        case 2:\n          return _context3.abrupt(\"return\", ExpoTaskManager.getRegisteredTasksAsync());\n\n        case 3:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function unregisterTaskAsync(taskName) {\n  return _regeneratorRuntime.async(function unregisterTaskAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          if (ExpoTaskManager.unregisterTaskAsync) {\n            _context4.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('TaskManager', 'unregisterTaskAsync');\n\n        case 2:\n          _validateTaskName(taskName);\n\n          _context4.next = 5;\n          return _regeneratorRuntime.awrap(ExpoTaskManager.unregisterTaskAsync(taskName));\n\n        case 5:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function unregisterAllTasksAsync() {\n  return _regeneratorRuntime.async(function unregisterAllTasksAsync$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          if (ExpoTaskManager.unregisterAllTasksAsync) {\n            _context5.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('TaskManager', 'unregisterAllTasksAsync');\n\n        case 2:\n          _context5.next = 4;\n          return _regeneratorRuntime.awrap(ExpoTaskManager.unregisterAllTasksAsync());\n\n        case 4:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nif (ExpoTaskManager) {\n  var eventEmitter = new EventEmitter(ExpoTaskManager);\n  eventEmitter.addListener(ExpoTaskManager.EVENT_NAME, function _callee(_ref) {\n    var data, error, executionInfo, eventId, taskName, taskExecutor, result;\n    return _regeneratorRuntime.async(function _callee$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            data = _ref.data, error = _ref.error, executionInfo = _ref.executionInfo;\n            eventId = executionInfo.eventId, taskName = executionInfo.taskName;\n            taskExecutor = tasks.get(taskName);\n            result = null;\n\n            if (!taskExecutor) {\n              _context6.next = 20;\n              break;\n            }\n\n            _context6.prev = 5;\n            _context6.next = 8;\n            return _regeneratorRuntime.awrap(taskExecutor({\n              data: data,\n              error: error,\n              executionInfo: executionInfo\n            }));\n\n          case 8:\n            result = _context6.sent;\n            _context6.next = 14;\n            break;\n\n          case 11:\n            _context6.prev = 11;\n            _context6.t0 = _context6[\"catch\"](5);\n            console.error(\"TaskManager: Task \\\"\" + taskName + \"\\\" failed:\", _context6.t0);\n\n          case 14:\n            _context6.prev = 14;\n            _context6.next = 17;\n            return _regeneratorRuntime.awrap(ExpoTaskManager.notifyTaskFinishedAsync(taskName, {\n              eventId: eventId,\n              result: result\n            }));\n\n          case 17:\n            return _context6.finish(14);\n\n          case 18:\n            _context6.next = 25;\n            break;\n\n          case 20:\n            console.warn(\"TaskManager: Task \\\"\" + taskName + \"\\\" has been executed but looks like it is not defined. Please make sure that \\\"TaskManager.defineTask\\\" is called during initialization phase.\");\n            _context6.next = 23;\n            return _regeneratorRuntime.awrap(ExpoTaskManager.notifyTaskFinishedAsync(taskName, {\n              eventId: eventId,\n              result: result\n            }));\n\n          case 23:\n            _context6.next = 25;\n            return _regeneratorRuntime.awrap(ExpoTaskManager.unregisterTaskAsync(taskName));\n\n          case 25:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, [[5, 11, 14, 18]], Promise);\n  });\n}","map":{"version":3,"sources":["../src/TaskManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter, UnavailabilityError } from '@unimodules/core';\n\nimport ExpoTaskManager from './ExpoTaskManager';\n\n/**\n * Error object that can be received through TaskManagerTaskBody when the task fails.\n */\nexport interface TaskManagerError {\n  code: string | number;\n  message: string;\n}\n\n/**\n * Represents the object that is passed to the task executor.\n */\nexport interface TaskManagerTaskBody {\n  /**\n   * An object of data passed to the task executor. Its properties depends on the type of the task.\n   */\n  data: object;\n\n  /**\n   * Error object if the task failed or `null` otherwise.\n   */\n  error: TaskManagerError | null;\n\n  /**\n   * Additional details containing unique ID of task event and name of the task.\n   */\n  executionInfo: {\n    eventId: string;\n    taskName: string;\n  };\n}\n\n/**\n * Represents an already registered task.\n */\nexport interface TaskManagerTask {\n  /**\n   * Name that the task is registered with.\n   */\n  taskName: string;\n\n  /**\n   * Type of the task which depends on how the task was registered.\n   */\n  taskType: string;\n\n  /**\n   * Provides `options` that the task was registered with.\n   */\n  options: any;\n}\n\n/**\n * @deprecated in favor of TaskManagerTask.\n */\nexport interface RegisteredTask extends TaskManagerTask {}\n\n/**\n * Type of task executor – a function that handles the task.\n */\nexport type TaskManagerTaskExecutor = (body: TaskManagerTaskBody) => void;\n\nconst tasks: Map<string, TaskManagerTaskExecutor> = new Map<string, TaskManagerTaskExecutor>();\n\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new TypeError('`taskName` must be a non-empty string.');\n  }\n}\n\n/**\n * Method that you use to define a task – it saves given task executor under given task name\n * which must be correlated with the task name used when registering the task.\n *\n * @param taskName Name of the task. It must be the same as the name you provided when registering the task.\n * @param taskExecutor A function that handles the task.\n */\nexport function defineTask(taskName: string, taskExecutor: TaskManagerTaskExecutor) {\n  if (!taskName || typeof taskName !== 'string') {\n    console.warn(`TaskManager.defineTask: 'taskName' argument must be a non-empty string.`);\n    return;\n  }\n  if (!taskExecutor || typeof taskExecutor !== 'function') {\n    console.warn(`TaskManager.defineTask: 'task' argument must be a function.`);\n    return;\n  }\n  tasks.set(taskName, taskExecutor);\n}\n\n/**\n * Checks whether the task is already defined.\n *\n * @param taskName Name of the task.\n */\nexport function isTaskDefined(taskName: string): boolean {\n  return tasks.has(taskName);\n}\n\n/**\n * Checks whether the task has been registered.\n *\n * @param taskName Name of the task.\n * @returns A promise resolving to boolean value. If `false` then even if the task is defined, it won't be called because it's not registered.\n */\nexport async function isTaskRegisteredAsync(taskName: string): Promise<boolean> {\n  if (!ExpoTaskManager.isTaskRegisteredAsync) {\n    throw new UnavailabilityError('TaskManager', 'isTaskRegisteredAsync');\n  }\n\n  _validateTaskName(taskName);\n  return ExpoTaskManager.isTaskRegisteredAsync(taskName);\n}\n\n/**\n * Retrieves an `options` object for provided `taskName`.\n *\n * @param taskName Name of the task.\n */\nexport async function getTaskOptionsAsync<TaskOptions>(taskName: string): Promise<TaskOptions> {\n  if (!ExpoTaskManager.getTaskOptionsAsync) {\n    throw new UnavailabilityError('TaskManager', 'getTaskOptionsAsync');\n  }\n\n  _validateTaskName(taskName);\n  return ExpoTaskManager.getTaskOptionsAsync(taskName);\n}\n\n/**\n * Provides informations about registered tasks.\n *\n * @returns Returns a promise resolving to an array containing all tasks registered by the app.\n */\nexport async function getRegisteredTasksAsync(): Promise<TaskManagerTask[]> {\n  if (!ExpoTaskManager.getRegisteredTasksAsync) {\n    throw new UnavailabilityError('TaskManager', 'getRegisteredTasksAsync');\n  }\n\n  return ExpoTaskManager.getRegisteredTasksAsync();\n}\n\n/**\n * Unregisters the task. Tasks are usually registered by other modules (e.g. expo-location).\n *\n * @param taskName Name of the task.\n */\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoTaskManager.unregisterTaskAsync) {\n    throw new UnavailabilityError('TaskManager', 'unregisterTaskAsync');\n  }\n\n  _validateTaskName(taskName);\n  await ExpoTaskManager.unregisterTaskAsync(taskName);\n}\n\n/**\n * Unregisters all tasks registered by the app. You may want to call this when the user is\n * signing out and you no longer need to track his location or run any other background tasks.\n */\nexport async function unregisterAllTasksAsync(): Promise<void> {\n  if (!ExpoTaskManager.unregisterAllTasksAsync) {\n    throw new UnavailabilityError('TaskManager', 'unregisterAllTasksAsync');\n  }\n\n  await ExpoTaskManager.unregisterAllTasksAsync();\n}\n\nif (ExpoTaskManager) {\n  const eventEmitter = new EventEmitter(ExpoTaskManager);\n  eventEmitter.addListener<TaskManagerTaskBody>(\n    ExpoTaskManager.EVENT_NAME,\n    async ({ data, error, executionInfo }) => {\n      const { eventId, taskName } = executionInfo;\n      const taskExecutor = tasks.get(taskName);\n      let result: any = null;\n\n      if (taskExecutor) {\n        try {\n          // Execute JS task\n          result = await taskExecutor({ data, error, executionInfo });\n        } catch (error) {\n          console.error(`TaskManager: Task \"${taskName}\" failed:`, error);\n        } finally {\n          // Notify manager the task is finished.\n          await ExpoTaskManager.notifyTaskFinishedAsync(taskName, { eventId, result });\n        }\n      } else {\n        console.warn(\n          `TaskManager: Task \"${taskName}\" has been executed but looks like it is not defined. Please make sure that \"TaskManager.defineTask\" is called during initialization phase.`\n        );\n        // No tasks defined -> we need to notify about finish anyway.\n        await ExpoTaskManager.notifyTaskFinishedAsync(taskName, { eventId, result });\n        // We should also unregister such tasks automatically as the task might have been removed\n        // from the app or just renamed - in that case it needs to be registered again (with the new name).\n        await ExpoTaskManager.unregisterTaskAsync(taskName);\n      }\n    }\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}